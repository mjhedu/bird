
function bittest(int a; int b)
{
        return a/(2*b) != (a+b)/(2*b);
}

function path_prepend(int a;int t)
{
        if ( t > 0 ) then bgp_path.prepend(a); else return 0;
        if ( t > 1 ) then bgp_path.prepend(a); else return 0;
        if ( t > 2 ) then bgp_path.prepend(a); else return 0;
        if ( t > 3 ) then bgp_path.prepend(a); else return 0;
        if ( t > 4 ) then bgp_path.prepend(a); else return 0;
}

function path_local_to_neigh(int set a)
{
	if ( bgp_path.len = 1 && bgp_path.last ~ a ) then
		return true;
	else
		return false;
}

define ALLOW_LOCAL		= 0x01;
define ALLOW_GLOBAL		= 0x02;
define ALLOW_FOREIGN		= 0x03;

define F_IMPORT			= 0x0F;
define F_EXPORT			= 0x10;
define F_IS_INTERNAL 		= 0x11;
define F_OVR_BGP_MED 		= 0x12;
define F_OVR_BGP_ORIGIN 	= 0x13;
define F_OVR_BGP_ORIGIN_LOCAL 	= 0x14;
define F_OVR_BGP_ORIGIN_GLOBAL 	= 0x15;
define F_OVR_BGP_ORIGIN_FOREIGN	= 0x16;
define F_KEEP_COMMUNITIES	= 0x17;

function prepare_origin_route(
	pair set global_community;
	int set flags; 
	int m; 
	int oc; 
	int p
) 
{
	if ( F_OVR_BGP_MED ~ flags ) then
		bgp_med = m;

	if ( F_OVR_BGP_ORIGIN ~ flags ) then
	        bgp_origin = oc;

	if !( F_KEEP_COMMUNITIES ~ flags ) then
		bgp_community.delete (global_community);

	if ( p > 0 ) then
		path_prepend(bgp_path.first, p);
		
}

define NET_PERMIT_ALL = [ 0.0.0.0/0{0,32} ];
define NET_DENY_NONE = [ 255.255.255.255/32{32,32} ];

function filter_generic(
	int direction;			# F_IMPORT or F_EXPORT
	int set flags; 			# See above this function
	prefix set net_permitted;	# Set of addresses permitted globally
	prefix set net_restricted;	# Set of restricted addresses
	int set as_permitted;		# Set of aut-nums permitted
	int own_as;	
	pair set global_community;	# The entire networks community
	pair local_community;		# This node's community
	int pl; int pg; int pf;
	int m; 				# BGP MED attribute
	int oc				# bgp_origin value (if do_oc=true)
)
{

	if !(net ~ (net_permitted)) || (net ~ (net_restricted))  then
		reject;

	if !( F_IS_INTERNAL ~ flags ) then {
		if ( direction = F_IMPORT ) then {
			if ( bgp_path.first = 0 || bgp_path.len = 0 ) then {
				print proto, "[", direction, "]: NULL bgp path detected:",net.ip,"/",net.len, " via ", from, " [",bgp_next_hop,"] - dropping";
				reject;
			}
		}
	}

	if !(0 ~ as_permitted) && !(bgp_path.last ~ (as_permitted)) then 
		reject;


	if ( source = RTS_STATIC || source = RTS_OSPF_EXT1 || source = RTS_OSPF_EXT2 ) then 
	{
		if ( ALLOW_LOCAL ~ flags ) then {
			if ( F_OVR_BGP_ORIGIN_LOCAL ~ flags ) then
				bgp_origin=oc;
			prepare_origin_route(global_community, flags, m, oc, pl);
			accept;
		} else 
    		    	reject;		
    	}

    	if bgp_community ~ (global_community) then
	{
		if ( ALLOW_GLOBAL ~ flags ) then {
			if ( F_OVR_BGP_ORIGIN_GLOBAL ~ flags ) then
				bgp_origin=oc;
			prepare_origin_route(global_community, flags, m, oc, pg );
			accept;
		} else
			reject;
	}

	if ( direction = F_IMPORT ) then {
		if ( bgp_path.last = own_as ) then {
			print proto, ": rejecting rogue foreign route with our AS:",net.ip,"/",net.len, " via ", from, " [",bgp_next_hop,"]";
			reject;
		}		
	}


	if ( ALLOW_FOREIGN ~ flags ) then {
		if ( F_OVR_BGP_ORIGIN_FOREIGN ~ flags ) then
			bgp_origin=oc;
		prepare_origin_route(global_community, flags, m, oc, pf);
		accept;
	} else
		reject;
       

	print "IMPOSSIBLE: ", proto, "[",direction ,"]: discarding route:",net.ip,"/",net.len, " via ", from, " [",bgp_next_hop,"]";

	reject;
}
